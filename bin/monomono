#!/bin/bash
# ==============================================================================
# MONOMONO - HAUPTSKRIPT (v12.5 - Finaler Hybrid-Auth-Fix)
# ==============================================================================
# Dieses Skript nutzt eine hybride Authentifizierung, um die Berechtigungsprobleme
# in automatisierten Umgebungen endg√ºltig zu l√∂sen.
# ==============================================================================

# --- Konfiguration & globale Variablen ---
CONFIG_DIR="$HOME/.monomono"
CONFIG_FILE="$CONFIG_DIR/config.json"
TEMP_KEY_FILE="$CONFIG_DIR/temp_private_key.pem"

# --- Befehlslogik (Hilfe & Reset) ---
case "$1" in
    --help|-h)
        # ... (Hilfetext)
        exit 0
        ;;
    --reset)
        if [ -d "$CONFIG_DIR" ]; then rm -rf "$CONFIG_DIR"; echo "‚úî Konfiguration zur√ºckgesetzt."; fi
        exit 0
        ;;
esac

# --- Hilfsfunktionen ---
ensure_app_configured() {
    if [ -f "$CONFIG_FILE" ] && jq -e '.app_id' "$CONFIG_FILE" >/dev/null 2>&1; then
        echo "‚úî MonoMono App-Konfiguration gefunden."
        return 0
    fi

    # --- APP-SETUP-WIZARD ---
    echo "--------------------------------------------------------------------"
    echo "üîë INFO: EINMALIGES APP-SETUP N√ñTIG"
    echo "--------------------------------------------------------------------"
    echo "‚ÄºÔ∏è  AKTION ERFORDERLICH: Bitte √∂ffne diese URL in deinem lokalen Browser:"
    echo "    https://github.com/settings/apps/new"
    echo
    echo "--- ANLEITUNG IM BROWSER ---"
    echo "1. App name:         Gib einen eindeutigen Namen ein (z.B. 'Meine-MonoMono-App')"
    echo "2. Homepage URL:     https://github.com/mannomannX/MonoMono"
    echo "3. Webhook:          ENTFERNE den Haken bei 'Active'."
    echo "4. Permissions:      Setze 'Actions', 'Contents', und 'Administration' auf 'Read & write'."
    echo "5. Klicke auf 'Create GitHub App'."
    echo "-------------------------------------------"
    
    read -p "? Dr√ºcke ENTER, nachdem du die App erstellt hast..."
    echo
    echo "--- DATEN SAMMELN ---"
    read -p "? Bitte gib deine 'App ID' ein (steht oben auf der Seite): " NEW_APP_ID
    read -p "? Bitte gib den Namen deiner App ein (exakte Schreibweise): " NEW_APP_NAME

    # ==============================================================================
    # ‚ú® HIER IST DER FINALE FIX ‚ú®
    # Wir fragen nicht mehr nach dem Pfad, sondern nach dem Inhalt der .pem-Datei.
    # ==============================================================================
    echo
    echo "Jetzt generiere einen 'Private Key':"
    echo "1. Klicke auf den Button [Generate a private key]."
    echo "2. Dein Browser l√§dt eine .pem-Datei herunter."
    echo "3. √ñFFNE diese .pem-Datei auf deinem lokalen PC mit einem Texteditor."
    echo "4. KOPIERE den gesamten Inhalt (inklusive der -----BEGIN/END----- Zeilen)."
    echo "5. F√ºge den kopierten Inhalt jetzt hier im Terminal ein."
    echo "   (Im Terminal: Rechtsklick oder Strg+Shift+V zum Einf√ºgen. Beende die Eingabe mit Strg+D auf einer neuen Zeile)"

    PEM_CONTENT=$(cat)

    if [ -z "$PEM_CONTENT" ]; then
        echo "‚ùå Fehler: Es wurde kein Inhalt eingef√ºgt. Bitte versuche es erneut."
        exit 1
    fi
    
    mkdir -p "$CONFIG_DIR"
    # Speichere den Inhalt in eine Datei innerhalb des Codespaces
    echo "$PEM_CONTENT" > "$TEMP_KEY_FILE"
    chmod 600 "$TEMP_KEY_FILE"
    # Speichere den Pfad zu dieser neuen Datei in der Konfiguration
    echo "{\"app_id\":\"$NEW_APP_ID\",\"private_key_path\":\"$TEMP_KEY_FILE\",\"app_name\":\"$NEW_APP_NAME\"}" > "$CONFIG_FILE"
    
    echo
    echo "‚úÖ App-Konfiguration erfolgreich gespeichert!"
    echo "--------------------------------------------------------------------"
}

get_installation_token() {
    # ... (Diese Funktion bleibt unver√§ndert und verwendet jetzt den korrekten Pfad)
    APP_ID=$(jq -r '.app_id' "$CONFIG_FILE")
    PRIVATE_KEY_PATH=$(jq -r '.private_key_path' "$CONFIG_FILE")
    APP_NAME=$(jq -r '.app_name' "$CONFIG_FILE")
    GITHUB_USER=$(jq -r '.github_user' "$CONFIG_FILE")

    if [ ! -f "$PRIVATE_KEY_PATH" ]; then
        echo "‚ùå Fehler: Die .pem-Datei wurde unter '$PRIVATE_KEY_PATH' nicht gefunden."
        exit 1
    fi

    # Erstelle JWT manuell
    NOW=$(date +%s)
    IAT=$(($NOW - 60))
    EXP=$(($NOW + 600))
    HEADER_B64=$(echo -n '{"alg":"RS256","typ":"JWT"}' | base64 | tr -d '\n' | tr -d '=' | tr '/+' '_-')
    PAYLOAD_B64=$(echo -n "{\"iat\":$IAT,\"exp\":$EXP,\"iss\":\"$APP_ID\"}" | base64 | tr -d '\n' | tr -d '=' | tr '/+' '_-')
    SIGNATURE_B64=$(openssl dgst -sha256 -sign "$PRIVATE_KEY_PATH" <(echo -n "$HEADER_B64.$PAYLOAD_B64") | base64 | tr -d '\n' | tr -d '=' | tr '/+' '_-')
    JWT="$HEADER_B64.$PAYLOAD_B64.$SIGNATURE_B64"
    echo "-> JWT f√ºr die App-Authentifizierung erstellt."

    # Finde Installations-ID
    INSTALLATION_ID=$(curl -s -H "Authorization: Bearer $JWT" -H "Accept: application/vnd.github.v3+json" https://api.github.com/app/installations | jq ".[] | select(.account.login==\"$GITHUB_USER\") | .id")

    while [ -z "$INSTALLATION_ID" ]; do
        echo "--------------------------------------------------------------------"
        echo "‚ö†Ô∏è  AKTION ERFORDERLICH: Die App '$APP_NAME' ist noch nicht installiert."
        echo "   Bitte √∂ffne den folgenden Link, um die App f√ºr deinen Account zu installieren:"
        echo "       https://github.com/settings/apps/$APP_NAME/installations"
        echo "   W√§hle dort 'All repositories' aus und klicke auf 'Install'."
        read -p "? Dr√ºcke ENTER, nachdem du die Installation im Browser abgeschlossen hast..."
        sleep 3
        INSTALLATION_ID=$(curl -s -H "Authorization: Bearer $JWT" -H "Accept: application/vnd.github.v3+json" https://api.github.com/app/installations | jq ".[] | select(.account.login==\"$GITHUB_USER\") | .id")
    done
    echo "‚úî App-Installation erfolgreich erkannt."

    # Erstelle Installation-Token
    INSTALLATION_TOKEN=$(curl -s -X POST -H "Authorization: Bearer $JWT" -H "Accept: application/vnd.github.v3+json" "https://api.github.com/app/installations/$INSTALLATION_ID/access_tokens" | jq -r '.token')
    
    if [ -z "$INSTALLATION_TOKEN" ] || [ "$INSTALLATION_TOKEN" == "null" ]; then
        echo "‚ùå Fehler beim Erstellen des Installation-Tokens."
        exit 1
    fi

    export GH_TOKEN=$INSTALLATION_TOKEN
    echo "‚úî Erfolgreich als MonoMono-App authentifiziert."
}

# --- HAUPTLOGIK ---

# 1. PR√úFUNG DER VORAUSSETZUNGEN
if ! command -v gh &>/dev/null || ! command -v fzf &>/dev/null || ! command -v jq &>/dev/null; then
    # --- SETUP-MODUS ---
    echo "üîé Checking system requirements..."
    echo "--------------------------------------------------------------------"
    echo "‚ö†Ô∏è  One or more required tools are not available."
    echo "   Starting the one-time installation wizard..."
    echo "--------------------------------------------------------------------"
    OS_TYPE="$(uname -s)"
    read -p "? Required tools (gh, fzf, jq) are missing. Install them now? (y/n) " choice
    if [[ ! "$choice" =~ ^[YyJj]$ ]]; then echo "‚ùå Aborted by user."; exit 1; fi

    case "$OS_TYPE" in
        Linux*)
            if command -v apt-get &>/dev/null; then
                echo "-> Updating package lists (apt-get update)..."
                sudo apt-get update
                if ! command -v gh &>/dev/null; then echo "-> Installing 'GitHub CLI' (gh)..."; sudo apt-get install -y gh; fi
                if ! command -v fzf &>/dev/null; then echo "-> Installing 'fzf'..."; sudo apt-get install -y fzf; fi
                if ! command -v jq &>/dev/null; then echo "-> Installing 'jq'..."; sudo apt-get install -y jq; fi
            elif command -v dnf &>/dev/null; then
                if ! command -v gh &>/dev/null; then sudo dnf install -y gh; fi
                if ! command -v fzf &>/dev/null; then sudo dnf install -y fzf; fi
                if ! command -v jq &>/dev/null; then sudo dnf install -y jq; fi
            else
                echo "‚ùå Error: Could not find a suitable Linux package manager (apt, dnf)." >&2; exit 1
            fi
            ;;
        Darwin*)
            if ! command -v brew &>/dev/null; then echo "‚ùå Error: Homebrew (brew) not found."; exit 1; fi
            if ! command -v gh &>/dev/null; then brew install gh; fi
            if ! command -v fzf &>/dev/null; then brew install fzf; fi
            if ! command -v jq &>/dev/null; then brew install jq; fi
            ;;
        *) echo "‚ùå Error: Unsupported operating system ($OS_TYPE)." >&2; exit 1;;
    esac
    echo
    echo "--------------------------------------------------------------------"
    echo "‚úÖ SETUP COMPLETE. Please close this terminal and open a new one."
    echo "--------------------------------------------------------------------"
    exit 0
fi

# --- ARBEITS-MODUS ---
echo "‚úî System ready. All tools found."
ensure_app_configured

if [ -f "$CONFIG_FILE" ] && jq -e '.github_user' "$CONFIG_FILE" >/dev/null 2>&1; then
    GITHUB_USER=$(jq -r '.github_user' "$CONFIG_FILE")
else
    read -p "? Bitte gib deinen GitHub-Benutzernamen ein: " GITHUB_USER
    TMP_JSON=$(jq --arg user "$GITHUB_USER" '. + {github_user: $user}' "$CONFIG_FILE")
    echo "$TMP_JSON" > "$CONFIG_FILE"
fi
echo "‚Ñπ Angemeldet als Benutzer: $GITHUB_USER"

# 4. AUTHENTIFIZIERUNG MIT PERSONAL ACCESS TOKEN (PAT)
echo "--------------------------------------------------------------------"
echo "üîë INFO: Ein pers√∂nlicher Zugriffstoken (PAT) wird ben√∂tigt."
echo "‚ÄºÔ∏è  AKTION ERFORDERLICH: √ñffne https://github.com/settings/tokens/new"
echo "   Anleitung: W√§hle die Scopes 'repo' UND 'workflow' aus, generiere den Token und kopiere ihn."
echo "--------------------------------------------------------------------"
PAT=""
while [ -z "$PAT" ]; do
    read -s -p "üëâ Bitte f√ºge den kopierten Token hier ein und dr√ºcke ENTER: " PAT; echo
done
echo "-> √úberpr√ºfe den Access Token..."
HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: token $PAT" https://api.github.com/user)
if [ "$HTTP_STATUS" -ne 200 ]; then
    echo "‚ùå FEHLER: Der Token ist ung√ºltig (HTTP-Status: $HTTP_STATUS)." >&2; exit 1
fi
VALIDATED_USER=$(curl -s -H "Authorization: token $PAT" https://api.github.com/user | jq -r '.login')
echo "‚úî Access Token ist g√ºltig f√ºr Benutzer '$VALIDATED_USER'."

# 4. PROJEKT-SETUP
echo "-------------------------------------------"
echo "üöÄ Starte den Assistenten..."
echo "1/5: Lade Repositories via API..."
REPOS_LIST=$(curl -s -H "Authorization: token $PAT" "https://api.github.com/user/repos?type=owner&per_page=100" | jq -r '.[].full_name')
if [ -z "$REPOS_LIST" ]; then echo "‚ùå Keine Repositories gefunden."; exit 1; fi
echo "‚úî Alle $(echo -e "$REPOS_LIST" | wc -l) Repositories erfolgreich geladen."

echo -e "2/5: W√§hle die zu fusionierenden Repos:\n(Navigation: Pfeiltasten, Auswahl: TAB, Best√§tigen: ENTER)"
SELECTED_REPOS=$(echo "$REPOS_LIST" | fzf --multi --height 40% --border --prompt="Select> ")
if [ -z "$SELECTED_REPOS" ]; then echo "‚ùå Aborted: No repositories selected."; exit 1; fi
SUB_REPOS=$(echo "$SELECTED_REPOS" | tr '\n' ',' | sed 's/,$//')

while true; do
    read -p "? 3/5: Wie soll das neue Fusions-Repo hei√üen? (Keine Leerzeichen): " FUSION_REPO_NAME
    if [[ "$FUSION_REPO_NAME" =~ \  ]]; then
        echo "‚ùå Fehler: Der Name darf keine Leerzeichen enthalten."
    elif [ -z "$FUSION_REPO_NAME" ]; then
        echo "‚ùå Fehler: Der Name darf nicht leer sein. Bitte versuche es erneut."
    else
        break
    fi
done

VISIBILITY_FLAG="--public"
read -p "? 4/5: Soll das Repository 'privat' sein? (j/n) " IS_PRIVATE
if [[ "$IS_PRIVATE" =~ ^[YyJj]$ ]]; then
    VISIBILITY_FLAG="--private"
fi

# 5. UPDATE-OPTIONEN
echo "-------------------------------------------"
echo "‚öôÔ∏è 5/5: Konfiguriere die Update-Methoden..."
CRON_SCHEDULE=""
read -p "? M√∂chtest du einen automatischen, zeitgesteuerten Sync aktivieren? (j/n) " ACTIVATE_SCHEDULE
if [[ "$ACTIVATE_SCHEDULE" =~ ^[YyJj]$ ]]; then
    read -p "? In welchem Intervall (in Stunden) soll der Sync laufen? (1-24) " SCHEDULE_HOURS
    CRON_SCHEDULE="  schedule:\n    - cron: '0 */${SCHEDULE_HOURS:-24} * * *'"
fi

SETUP_WEBHOOKS=false
read -p "? Sollen Echtzeit-Updates √ºber Sub-Repo-Workflows eingerichtet werden? (j/n) " ACTIVATE_WEBHOOKS
if [[ "$ACTIVATE_WEBHOOKS" =~ ^[YyJj]$ ]]; then
    SETUP_WEBHOOKS=true
fi

# 6. REPO ERSTELLEN & SECRET SETZEN
echo "-> Creating repo '$FUSION_REPO_NAME'..."
# Wir authentifizieren diesen einen Befehl explizit mit dem PAT
GH_TOKEN=$PAT gh repo create "$GITHUB_USER/$FUSION_REPO_NAME" "$VISIBILITY_FLAG" --description "Automatic fusion repo by MonoMono" >/dev/null || { echo "‚ùå Error creating the GitHub repo."; exit 1; }
echo "‚úî Repository erfolgreich erstellt."

# JETZT wechseln wir zum sicheren App-Token f√ºr den Rest des Prozesses
echo "-> Wechsle zur App-Authentifizierung f√ºr weitere Aktionen..."
get_installation_token # Holt den App-Token und exportiert ihn als GH_TOKEN

echo "-> Speichere den App-Token sicher als 'ACCESS_TOKEN' Secret im neuen Repo..."
# gh secret set verwendet jetzt den App-Token (GH_TOKEN)
echo -n "$GH_TOKEN" | gh secret set ACCESS_TOKEN --repo "$GITHUB_USER/$FUSION_REPO_NAME" || { echo "‚ùå Fehler beim Setzen des Secrets."; exit 1; }
echo "‚úî Secret erfolgreich im Repository '$FUSION_REPO_NAME' gespeichert."

WORKFLOW_NAME="Fusion-Repo Erstellen & Aktualisieren"
ON_TRIGGERS="on:\n  workflow_dispatch:"
if [ -n "$CRON_SCHEDULE" ]; then
    ON_TRIGGERS+="\n$CRON_SCHEDULE"
fi

read -r -d '' WORKFLOW_CONTENT << EOM
name: 'Fusion-Repo Erstellen & Aktualisieren'
on:
  workflow_dispatch:
  repository_dispatch:
    types: [monomono-sync-event]
jobs:
  sync-repos:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout fusion repo
        uses: actions/checkout@v4
        with:
          token: \${{ secrets.ACCESS_TOKEN }}
      - name: Clone sub-repos
        run: |
          git config --global url."https://x-access-token:\${{ secrets.ACCESS_TOKEN }}@github.com/".insteadOf "https://github.com/"
          REPOS_TO_SYNC=\${{ inputs.repos || '$SUB_REPOS' }}
          for repo in \$(echo "\$REPOS_TO_SYNC" | sed 's/,/ /g'); do
            folder_name=\$(basename \$repo)
            echo "-> Cloning \$repo into \$folder_name..."
            rm -rf "\$folder_name"
            git clone --depth 1 https://github.com/\$repo.git "\$folder_name" && rm -rf "\$folder_name/.git"
          done
      - name: Create intelligent README
        run: |
          sudo apt-get update >/dev/null && sudo apt-get install -y tree >/dev/null
          echo "# ü§ñ MonoMono Fusions-Repo" > README.md
          echo "" >> README.md
          echo "Dieses Repository ist eine automatisch generierte Zusammenf√ºhrung." >> README.md
          echo "" >> README.md
          echo "## üó∫Ô∏è Projekt-Map" >> README.md
          echo "### üß© Projekt-Komponenten" >> README.md
          for repo in \$(echo "\${{ inputs.repos || '$SUB_REPOS' }}" | sed 's/,/ /g'); do
            echo "- **[\$(basename \$repo)](./\$(basename \$repo))** (Original: [\$repo](https://github.com/\$repo))" >> README.md
          done
          echo "" >> README.md
          echo "### üå≥ Verzeichnisstruktur" >> README.md
          echo "\`\`\`" >> README.md
          tree -L 2 -I 'README.md' >> README.md
          echo "\`\`\`" >> README.md
          echo "" >> README.md
          echo "> Letzte Aktualisierung: \$(date)" >> README.md
      - name: Commit and push changes
        run: |
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'
          git add .
          if ! git diff-index --quiet HEAD; then
            git commit -m "feat: Sync sub-repos and update project map"
            git push
          else
            echo "No new changes found."
          fi
EOM
TEMP_DIR=$(mktemp -d)
cd "$TEMP_DIR" || exit 1
git clone "https://x-access-token:$PAT@github.com/$GITHUB_USER/$FUSION_REPO_NAME.git" . >/dev/null 2>&1 || { echo "‚ùå Error cloning repo."; rm -rf "$TEMP_DIR"; exit 1; }
mkdir -p .github/workflows
echo -e "$WORKFLOW_CONTENT" > .github/workflows/sync.yml
git config user.name "MonoMono Script"
git config user.email "bot@users.noreply.github.com"
git add .
git commit -m "CI: Add initial sync workflow"
git push --force origin main >/dev/null 2>&1 || { echo "‚ùå Error pushing workflow."; rm -rf "$TEMP_DIR"; exit 1; }
cd - >/dev/null
rm -rf "$TEMP_DIR"
echo "‚úî Workflow file successfully pushed to GitHub."

# 7. ECHTZEIT-SYNC EINRICHTEN (TRIGGER-WORKFLOWS)
if [[ "$SETUP_WEBHOOKS" = true ]]; then
    echo "-> Richte Echtzeit-Synchronisierung f√ºr die Sub-Repos ein..."

    # ==============================================================================
    # ‚ú® HIER IST DER FINALE FIX ‚ú®
    # Wir √ºbergeben den PAT-Secret korrekt an die GH_TOKEN-Umgebungsvariable.
    # ==============================================================================
    read -r -d '' TRIGGER_WORKFLOW_CONTENT << EOM
# MonoMono Trigger Workflow
name: MonoMono Sync Trigger
on:
  push:
    branches: [main, master]
jobs:
  dispatch:
    runs-on: ubuntu-latest
    steps:
      - name: Send dispatch to fusion repo
        env:
          FUSION_REPO: \${{ secrets.MONOMONO_FUSION_REPO }}
          GH_TOKEN: \${{ secrets.MONOMONO_PAT }}
        run: |
          if [ -z "\$FUSION_REPO" ]; then
            echo "Fehler: Secret MONOMONO_FUSION_REPO ist nicht gesetzt."
            exit 1
          fi
          
          echo "Sending dispatch to \$FUSION_REPO"
          gh api --method POST "repos/\$FUSION_REPO/dispatches" -f "event_type=monomono-sync-event"
EOM

    for repo in $(echo $SUB_REPOS | sed "s/,/ /g"); do
        echo "   - Konfiguriere Sub-Repo: $repo"
        
        FUSION_REPO_FULL_NAME="$GITHUB_USER/$FUSION_REPO_NAME"
        echo "     - Setze Secrets im Sub-Repo..."
        echo -n "$FUSION_REPO_FULL_NAME" | gh secret set MONOMONO_FUSION_REPO --repo "$repo"
        echo -n "$PAT" | gh secret set MONOMONO_PAT --repo "$repo"

        echo "     - Pushe Trigger-Workflow zum Sub-Repo..."
        TEMP_SUB_DIR=$(mktemp -d)
        git clone "https://x-access-token:$PAT@github.com/$repo.git" "$TEMP_SUB_DIR" >/dev/null 2>&1
        
        mkdir -p "$TEMP_SUB_DIR/.github/workflows"
        echo -e "$TRIGGER_WORKFLOW_CONTENT" > "$TEMP_SUB_DIR/.github/workflows/monomono-trigger.yml"
        
        cd "$TEMP_SUB_DIR" || exit
        git config user.name "MonoMono Script"
        git add .github/workflows/monomono-trigger.yml
        if ! git diff-index --quiet HEAD; then
            git commit -m "feat: Add MonoMono sync trigger"
            git push
        else
            echo "     - Trigger-Workflow ist bereits aktuell."
        fi
        cd - >/dev/null
        rm -rf "$TEMP_SUB_DIR"
    done
fi

# 8. WORKFLOW STARTEN
echo "-> Warte, bis der Workflow auf GitHub sichtbar ist..."
WORKFLOW_FOUND=false
for i in {1..5}; do
  if gh workflow list --repo "$GITHUB_USER/$FUSION_REPO_NAME" 2>/dev/null | grep -q "$WORKFLOW_NAME"; then
    echo "‚úî Workflow gefunden."; WORKFLOW_FOUND=true; break;
  fi
  if [ $i -lt 5 ]; then echo "   - Noch nicht gefunden, versuche es in 2 Sekunden erneut..."; sleep 2; fi
done
if ! $WORKFLOW_FOUND; then echo "‚ùå Error: Workflow not found after 10 seconds."; exit 1; fi
echo "-> Starte den ersten Lauf des Workflows..."
gh workflow run sync.yml --repo "$GITHUB_USER/$FUSION_REPO_NAME" || { echo "‚ùå Error starting the workflow."; exit 1; }

echo
echo "$TEXT_ALL_DONE"
echo "üëÄ Verfolge den Fortschritt hier: https://github.com/$GITHUB_USER/$FUSION_REPO_NAME/actions"