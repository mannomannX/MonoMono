#!/bin/bash
# ==============================================================================
# MonoMono Upgrade-Skript v2.1 (mit intelligenter Fallback-Logik)
# ==============================================================================
# Aktualisiert den Workflow in einem bestehenden Fusions-Repo und nutzt dabei
# mehrere Methoden, um die Konfiguration auch aus alten Repos zu erkennen.
# ==============================================================================
CONFIG_FILE="$HOME/.monomono_config"

# --- Funktion zur PAT-Abfrage ---
ensure_pat() {
    # ... (Diese Funktion bleibt unver√§ndert)
    if [ -f "$CONFIG_FILE" ]; then source "$CONFIG_FILE"; fi
    if [ -z "$MONOMONO_PAT" ]; then
        echo "üîë INFO: Ein pers√∂nlicher Zugriffstoken (PAT) wird f√ºr die Authentifizierung ben√∂tigt."
        read -s -p "üëâ Bitte f√ºge einen g√ºltigen Token mit 'repo' und 'workflow' Rechten hier ein: " PAT; echo
        HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: token $PAT" https://api.github.com/user)
        if [ "$HTTP_STATUS" -ne 200 ]; then echo "‚ùå FEHLER: Der Token ist ung√ºltig (HTTP-Status: $HTTP_STATUS)." >&2; exit 1; fi
        echo "MONOMONO_PAT='$PAT'" >> "$CONFIG_FILE"
        MONOMONO_PAT=$PAT
    fi
    export GH_TOKEN=$MONOMONO_PAT
    echo "‚úî Authentifizierung f√ºr diese Sitzung gesetzt."
}

# --- HAUPTLOGIK ---
echo "MonoMono Workflow Upgrade-Assistent"
echo "-------------------------------------"
read -p "? Welches Fusions-Repo soll aktualisiert werden? (user/repo): " FUSION_REPO
if [ -z "$FUSION_REPO" ]; then echo "‚ùå Fehler: Eingabe darf nicht leer sein."; exit 1; fi

ensure_pat
GITHUB_USER=$(curl -s -H "Authorization: token $MONOMONO_PAT" https://api.github.com/user | jq -r '.login')

# --- Intelligente Sub-Repo-Erkennung mit Fallbacks ---
echo "-> Analysiere das Repository '$FUSION_REPO'..."
TEMP_DIR=$(mktemp -d)
git clone "https://x-access-token:$MONOMONO_PAT@github.com/$FUSION_REPO.git" "$TEMP_DIR" >/dev/null 2>&1 || { echo "‚ùå Fehler beim Klonen des Repos."; rm -rf "$TEMP_DIR"; exit 1; }

WORKFLOW_FILE_PATH="$TEMP_DIR/.github/workflows/sync.yml"
SUB_REPOS=""

# VERSUCH 1: Aus dem Workflow parsen
if [ -f "$WORKFLOW_FILE_PATH" ]; then
    SUB_REPOS_LINE=$(grep -m 1 'REPOS_TO_SYNC=' "$WORKFLOW_FILE_PATH")
    SUB_REPOS=$(echo "$SUB_REPOS_LINE" | sed -e "s/.*inputs.repos || '//" -e "s/' *}}//")
fi

# FALLBACK 1: Aus der Verzeichnisstruktur ableiten
if [ -z "$SUB_REPOS" ]; then
    echo "‚ö†Ô∏è Konnte Sub-Repos nicht aus dem Workflow lesen. Versuche Analyse der Verzeichnisstruktur..."
    # Finde alle Ordner auf der obersten Ebene, ignoriere ".github"
    SUB_REPO_NAMES=$(find "$TEMP_DIR" -maxdepth 1 -mindepth 1 -type d -not -path '*/.git*' -not -path '*/.github*' -exec basename {} \;)
    
    if [ -n "$SUB_REPO_NAMES" ]; then
        echo "‚úî Folgende potenzielle Sub-Repo-Ordner gefunden: $SUB_REPO_NAMES"
        read -p "? Welchem GitHub-Benutzer oder welcher Organisation geh√∂ren diese Repos? (Standard: $GITHUB_USER): " SUB_REPO_OWNER
        SUB_REPO_OWNER=${SUB_REPO_OWNER:-$GITHUB_USER}

        # Baue die vollst√§ndigen Namen zusammen (user/repo)
        for name in $SUB_REPO_NAMES; do
            if [ -z "$SUB_REPOS" ]; then
                SUB_REPOS="$SUB_REPO_OWNER/$name"
            else
                SUB_REPOS="$SUB_REPOS,$SUB_REPO_OWNER/$name"
            fi
        done
    fi
fi

# FALLBACK 2: Manuelle Eingabe
if [ -z "$SUB_REPOS" ]; then
    echo "‚ùå Konnte Sub-Repos nicht automatisch erkennen."
    read -p "? Bitte gib die zugeh√∂rigen Sub-Repos manuell ein (user/repo1,user/repo2,...): " SUB_REPOS
fi

if [ -z "$SUB_REPOS" ]; then
    echo "‚ùå Fehler: Keine Sub-Repos angegeben. Abbruch."
    rm -rf "$TEMP_DIR"
    exit 1
fi

echo "‚úî Konfiguration f√ºr Upgrade erfolgreich geladen. Verbundene Repos: $SUB_REPOS"
ON_TRIGGERS=$(sed -n '/^on:/,/^jobs:/p' "$WORKFLOW_FILE_PATH" | sed '$d')

# --- Generiere den neuen, korrekten Workflow-Inhalt ---
read -r -d '' WORKFLOW_CONTENT << EOM
name: 'Fusion-Repo Erstellen & Aktualisieren'
on:
  workflow_dispatch:
  repository_dispatch:
    types: [monomono-sync-event]
jobs:
  sync-repos:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout fusion repo
        uses: actions/checkout@v4
        with:
          token: \${{ secrets.ACCESS_TOKEN }}
      - name: Clone sub-repos
        run: |
          git config --global url."https://x-access-token:\${{ secrets.ACCESS_TOKEN }}@github.com/".insteadOf "https://github.com/"
          REPOS_TO_SYNC=\${{ inputs.repos || '$SUB_REPOS' }}
          for repo in \$(echo "\$REPOS_TO_SYNC" | sed 's/,/ /g'); do
            folder_name=\$(basename \$repo)
            echo "-> Cloning \$repo into \$folder_name..."
            rm -rf "\$folder_name"
            git clone --depth 1 https://github.com/\$repo.git "\$folder_name" && rm -rf "\$folder_name/.git"
          done
      - name: Create intelligent README
        run: |
          sudo apt-get update >/dev/null && sudo apt-get install -y tree >/dev/null
          echo "# ü§ñ MonoMono Fusions-Repo" > README.md
          echo "" >> README.md
          echo "Dieses Repository ist eine automatisch generierte Zusammenf√ºhrung." >> README.md
          echo "" >> README.md
          echo "## üó∫Ô∏è Projekt-Map" >> README.md
          echo "### üß© Projekt-Komponenten" >> README.md
          for repo in \$(echo "\${{ inputs.repos || '$SUB_REPOS' }}" | sed 's/,/ /g'); do
            echo "- **[\$(basename \$repo)](./\$(basename \$repo))** (Original: [\$repo](https://github.com/\$repo))" >> README.md
          done
          echo "" >> README.md
          echo "### üå≥ Verzeichnisstruktur" >> README.md
          echo "\`\`\`" >> README.md
          tree -L 2 -I 'README.md' >> README.md
          echo "\`\`\`" >> README.md
          echo "" >> README.md
          echo "> Letzte Aktualisierung: \$(date)" >> README.md
      - name: Commit and push changes
        run: |
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'
          git add .
          if ! git diff-index --quiet HEAD; then
            git commit -m "feat: Sync sub-repos and update project map"
            git push
          else
            echo "No new changes found."
          fi
EOM

# --- Pushe den neuen Workflow in das Repo ---
echo "-> √úberschreibe den alten Workflow in '$FUSION_REPO'..."
echo -e "$NEW_WORKFLOW_CONTENT" > "$WORKFLOW_FILE_PATH"
cd "$TEMP_DIR" || exit
git add .github/workflows/sync.yml
if ! git diff-index --quiet HEAD; then
    git commit -m "fix(workflow): Upgrade and repair MonoMono sync logic"
    git push
else
    echo "‚úî Workflow ist bereits auf dem neuesten Stand."
fi
cd - >/dev/null
rm -rf "$TEMP_DIR"

echo "‚úÖ Workflow f√ºr '$FUSION_REPO' erfolgreich aktualisiert!"
echo "   F√ºhre 'monomono-update $FUSION_REPO' aus, um die √Ñnderungen zu sehen."