#!/bin/bash
# ==============================================================================
# MONOMONO-UPGRADE v1.6 (Final & Bilingual)
# ==============================================================================
# Aktualisiert ein Fusions-Repo. Erkennt automatisch alte und neue
# Workflow-Versionen und kann im "Repair-Modus" ein kaputtes Setup wiederherstellen.
# ==============================================================================

auth_check() {
    if ! gh auth status >/dev/null 2>&1; then
        echo "‚ö†Ô∏è  Du scheinst nicht bei der GitHub CLI angemeldet zu sein."
        read -p "? Soll 'gh auth login' jetzt ausgef√ºhrt werden? (j/n) " choice
        if [[ "$choice" =~ ^[YyJj]$ ]]; then gh auth login; else echo "‚ùå Abbruch."; exit 1; fi
    fi
    GITHUB_USER=$(gh api user --jq .login)
    echo "‚úî Authentifiziert als '$GITHUB_USER'."
}

get_installation_token() {
    local config_file=$1; local gh_user=$2;
    APP_ID=$(jq -r '.app_id' "$config_file"); PRIVATE_KEY_PATH=$(jq -r '.private_key_path' "$config_file");
    if [ ! -f "$PRIVATE_KEY_PATH" ]; then echo "‚ùå Fehler: .pem-Datei nicht gefunden." >&2; exit 1; fi
    NOW=$(date +%s); IAT=$(($NOW - 60)); EXP=$(($NOW + 600));
    HEADER_B64=$(echo -n '{"alg":"RS256","typ":"JWT"}' | base64 | tr -d '\n=' | tr '/+' '_-');
    PAYLOAD_B64=$(echo -n "{\"iat\":$IAT,\"exp\":$EXP,\"iss\":\"$APP_ID\"}" | base64 | tr -d '\n=' | tr '/+' '_-');
    SIGNATURE_B64=$(openssl dgst -sha256 -sign "$PRIVATE_KEY_PATH" <(echo -n "$HEADER_B64.$PAYLOAD_B64") | base64 | tr -d '\n=' | tr '/+' '_-');
    JWT="$HEADER_B64.$PAYLOAD_B64.$SIGNATURE_B64";
    INSTALLATION_ID=$(curl -s -H "Authorization: Bearer $JWT" -H "Accept: application/vnd.github.v3+json" https://api.github.com/app/installations | jq ".[] | select(.account.login==\"$gh_user\") | .id");
    if [ -z "$INSTALLATION_ID" ]; then echo "‚ùå Fehler: App nicht installiert."; exit 1; fi;
    INSTALLATION_TOKEN=$(curl -s -X POST -H "Authorization: Bearer $JWT" -H "Accept: application/vnd.github.v3+json" "https://api.github.com/app/installations/$INSTALLATION_ID/access_tokens" | jq -r '.token');
    if [ -z "$INSTALLATION_TOKEN" ] || [ "$INSTALLATION_TOKEN" == "null" ]; then echo "‚ùå Fehler beim Erstellen des Tokens."; exit 1; fi;
    export GENERATED_APP_TOKEN=$INSTALLATION_TOKEN;
}

# --- HAUPTLOGIK ---
auth_check
CONFIG_DIR="$HOME/.monomono"; CONFIG_FILE="$CONFIG_DIR/config.json"
if [ ! -f "$CONFIG_FILE" ]; then echo "‚ùå Fehler: Keine Konfiguration gefunden."; exit 1; fi

read -p "? Welches Fusions-Repo soll aktualisiert werden? (user/repo): " FUSION_REPO
if [ -z "$FUSION_REPO" ]; then echo "‚ùå Abbruch."; exit 1; fi

echo "--------------------------------------------------------------------";
echo "üîë INFO: Ein pers√∂nlicher Zugriffstoken (PAT) wird ben√∂tigt.";
echo "--------------------------------------------------------------------";
PAT=""; while [ -z "$PAT" ]; do read -s -p "üëâ Token einf√ºgen: " PAT; echo; done

echo "-> Erneuere App-Token..."; get_installation_token "$CONFIG_FILE" "$GITHUB_USER"
echo "-> Speichere neuen Token als Secret...";
GH_TOKEN=$PAT gh secret set ACCESS_TOKEN --repo "$FUSION_REPO" --body "$GENERATED_APP_TOKEN" || { echo "‚ùå Fehler beim Setzen des Secrets."; exit 1; }
echo "‚úî Authentifizierung erneuert.";

echo "-> Lese Konfiguration aus '$FUSION_REPO'...";
WORKFLOW_RESPONSE=$(GH_TOKEN=$PAT gh api "repos/$FUSION_REPO/contents/.github/workflows/sync.yml" 2>/dev/null)
IS_UPDATE=false; SUB_REPOS=""

if echo "$WORKFLOW_RESPONSE" | jq -e '.sha' > /dev/null; then
    IS_UPDATE=true; WORKFLOW_SHA=$(echo "$WORKFLOW_RESPONSE" | jq -r .sha);
    WORKFLOW_CONTENT=$(echo "$WORKFLOW_RESPONSE" | jq -r .content | base64 --decode);
    
    # NEUE, BILINGUALE EXTRAKTION
    SUB_REPOS=$(echo "$WORKFLOW_CONTENT" | grep -oP "REPOS_TO_SYNC='([^']*)'" | sed -E "s/REPOS_TO_SYNC='([^']*)'/\1/")
    if [ -z "$SUB_REPOS" ]; then
        echo "   (Altes Workflow-Format erkannt, extrahiere anders...)"
        SUB_REPOS=$(echo "$WORKFLOW_CONTENT" | grep -oP "for repo in \\\$\(echo '([^']*)'" | head -n1 | sed -E "s/for repo in \\\$\(echo '([^']*)'/\1/")
    fi
else
    echo "‚ö†Ô∏è  Warnung: 'sync.yml' nicht gefunden. Wechsle in den Repair-Modus.";
    read -p "? Gib die Sub-Repos an, die verbunden sein sollen (user/repo1,...): " SUB_REPOS;
fi

if [ -z "$SUB_REPOS" ]; then echo "‚ùå Abbruch: Keine Sub-Repos gefunden oder angegeben."; exit 1; fi
echo "‚úî Konfiguriere f√ºr: $SUB_REPOS";

read -r -d '' SYNC_WORKFLOW_TEMPLATE << EOM
name: 'Fusion-Repo Sync'
on:
  workflow_dispatch:
  repository_dispatch:
    types: [monomono-sync-event]
jobs:
  sync-repos:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout fusion repo
        uses: actions/checkout@v4
        with:
          token: \${{ secrets.ACCESS_TOKEN }}
      - name: Sync and Rebuild
        run: |
          REPOS_TO_SYNC='${SUB_REPOS}'
          echo "-> Pruning obsolete directories..."
          ALL_DIRS=\$(find . -maxdepth 1 -mindepth 1 -type d ! -name '.git' -exec basename {} \;)
          for dir in \$ALL_DIRS; do
            is_in_sync_list=false
            for repo_in_list in \$(echo "\$REPOS_TO_SYNC" | sed "s/,/ /g"); do
              if [ "\$(basename "\$repo_in_list")" == "\$dir" ]; then
                is_in_sync_list=true
                break
              fi
            done
            if [ "\$is_in_sync_list" == "false" ]; then
              echo "   - Deleting obsolete directory: \$dir"
              rm -rf "\$dir"
            fi
          done
          echo "-> Cloning sub-repos..."
          for repo in \$(echo "\$REPOS_TO_SYNC" | sed "s/,/ /g"); do
            folder_name=\$(basename \$repo)
            rm -rf "\$folder_name"
            git clone --depth 1 "https://x-access-token:\${{ secrets.ACCESS_TOKEN }}@github.com/\$repo.git" "\$folder_name" --quiet && rm -rf "\$folder_name/.git"
          done
EOM

if [ "$IS_UPDATE" = true ]; then
    echo "-> Aktualisiere Haupt-Workflow...";
    GH_TOKEN=$PAT gh api --method PUT "repos/$FUSION_REPO/contents/.github/workflows/sync.yml" -f message="build: Upgrade monomono sync workflow" -f content="$(echo -n "$SYNC_WORKFLOW_TEMPLATE" | base64)" -f sha="$WORKFLOW_SHA" >/dev/null;
else
    echo "-> Erstelle neuen Haupt-Workflow...";
    GH_TOKEN=$PAT gh api --method PUT "repos/$FUSION_REPO/contents/.github/workflows/sync.yml" -f message="build: Create/Repair monomono sync workflow" -f content="$(echo -n "$SYNC_WORKFLOW_TEMPLATE" | base64)" >/dev/null;
fi

echo "-> Aktualisiere Trigger-Workflows in allen Sub-Repos..."
for repo in $(echo "$SUB_REPOS" | sed "s/,/ /g"); do
    echo "   - Verarbeite $repo..."
    SHA_TRIGGER=$(GH_TOKEN=$PAT gh api "repos/$repo/contents/.github/workflows/monomono-trigger.yml" --jq .sha 2>/dev/null)
    if [ -n "$SHA_TRIGGER" ]; then
        GH_TOKEN=$PAT gh api --method PUT "repos/$repo/contents/.github/workflows/monomono-trigger.yml" -f message="build: Upgrade monomono trigger workflow" -f content="$(echo -n "$TRIGGER_WORKFLOW_TEMPLATE" | base64)" -f sha="$SHA_TRIGGER" >/dev/null
    else
        GH_TOKEN=$PAT gh api --method PUT "repos/$repo/contents/.github/workflows/monomono-trigger.yml" -f message="feat: Add/Repair monomono trigger workflow" -f content="$(echo -n "$TRIGGER_WORKFLOW_TEMPLATE" | base64)" >/dev/null
    fi
done
echo "‚úî Trigger-Workflows erfolgreich aktualisiert."

echo "-> Sto√üe einen Sync-Lauf an, um den Zustand zu bereinigen..."
gh workflow run sync.yml --repo "$FUSION_REPO"
echo "‚úÖ Prozess abgeschlossen. Der Aufr√§um-Prozess wurde gestartet."